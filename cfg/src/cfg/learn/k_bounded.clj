(ns cfg.learn.k-bounded
  (:require [clojure.set :refer [union]]
            [clojure.string :refer [join]]
            [bigml.sampling.stream :as stream]
            [cfg.coll-util :refer [queue]]
            [cfg.learn.util :refer :all]
            [cfg.prune :refer [prune-cfg]]
            [cfg.lang :refer [parse-trees lang-seq in-lang]]
            [cfg.scfg :refer [cfg->scfg make-strongly-consistent sample]]
            [cfg.cfg :refer [cfg add-rule remove-rule
                             cnf-leaf? show-cfg]]))

(defn stream-sample
  "Return a vector of `n` strings generated by the grammar `g`, randomly
  sampled from a stream of strings generated by the grammar, in length order."
  [g n]
  (-> (lang-seq g)
      (stream/sample 1 n :rate true)
      (->> (take n) vec)))

(defn scfg-sample
  "Return a vector of `n` strings generated by assignig probabilities to the
  rules in grammar `g`. This sampling system does not provide samples in
  length order, and could contain repeats."
  [g n]
  (let [sg (-> g cfg->scfg make-strongly-consistent)]
    (vec (repeatedly n #(sample sg)))))

(defn- diagnose
  "Given a non-terminal membership predicate `member*`, and a parse-tree `t`,
  return a bad production used in the parse-tree."
  [member* t]
  (letfn [(consume-child [state [rule & children]]
            (if-let [bad-child (some (fn [{cnt :nt cy :yield :as child}]
                                       (when-not (member* cnt cy) child))
                                     children)]
              (update-in state [0] conj  bad-child)
              (update-in state [1] conj! rule)))]
    (loop [q         (queue t)
           bad-rules (transient #{})]
      (if (seq q)
        (let [{:keys [children]} (peek q)
              [q* bad-rules*] (reduce consume-child
                                      [(pop q) bad-rules]
                                      children)]
          (recur q* bad-rules*))
        (persistent! bad-rules)))))

(defn- candidate
  "Given a multimap of non-terminals to terminals they cannot yield (the
  `blacklist`), a sequence of non-terminals, `nts` and a vector of tokens,
  `toks`, give a collection of rules that, when added to the grammar associated
  with `blacklist` and `nts`, will allow it to recognise `toks`."
  [nts blacklist toks]
  (for [t toks, nt nts,
        :let  [leaf [nt t]]
        :when (not (blacklist leaf))]
    leaf))

(defn- init-grammar
  "Given a sequence of non-terminals `nts`, create the CNF grammar containing
  all possible branches of those non-terminals (without any leaf nodes)."
  [nts]
  (reduce add-rule (cfg)
          (for [a nts b nts c nts]
            [a b c])))

(defn learn
  "Takes two functions:

   * `counter*` Takes a grammar, and, if it is the correct one, returns `nil`,
     otherwise, returns a vector of tokens that provides a counter-example
     showing a string that either should be in the language and is not, or
     shouldn't be in the language but is.
   * `member*` Takes a non-terminal, and a sequence of tokens and determines
     whether it is possible to yield the tokens from the non-terminal in
     the target grammar.

  As well as a list of non-terminals `nts`, and attempts to learn a grammar
  with non-terminals in `nts` and rules governed by the responses from queries
  to `counter*` and `member*`."
  [member* counter* nts]
  (let [init-g (init-grammar nts)]
    (loop [g init-g, blacklist #{}
           member? (memoize member*)]
      (let [pg (prune-cfg g)]
        (if-let [c (counter* pg)]
          (if-let [t (parse-trees g c)]
            (let [bad-rules  (diagnose member? t)
                  bad-leaves (filter cnf-leaf? bad-rules)]
              (recur (reduce remove-rule g bad-rules)
                     (into blacklist bad-leaves) member?))

            (let [new-g (->> (candidate nts blacklist c)
                             (reduce add-rule g))]
              (if (parse-trees new-g c)
                (recur new-g blacklist member?)
                (recur init-g #{} (memoize member*))))) ;; RESET
          pg)))))

(defn interactive-counter
  "A form of the `counter*` predicate used in the learning algorithm that
  asks for its response from the user."
  [g]
  (println "Correct?")
  (println (show-cfg g))
  (print   "Blank for yes, Counter-example for no: ")
  (flush)
  (let [input (read-line)]
    (println)
    (when (seq input)
      (read-string (str \[ input \])))))

(defn present-samples
  "Print the given vector of `samples` and ask the user to pick one."
  [samples]
  (println "Are these samples correct?")
  (doseq [[i toks] (map vector (iterate inc 1) samples)]
    (println (format "%-2d. %s" i toks)))
  (print "Blank for yes, index of counter-example for no: ")
  (flush)
  (let [input (read-line)]
    (when (seq input)
      (get samples (dec (read-string input))))))

(defn sample-counter
  "A `counter*` predicate that ensures every word in `corpus` is recognised by
  the given grammar. If not, then the offending word is returned.

  Otherwise, generates samples from the grammar, and passes them on to the
  `sample-tester` which should return a false-positive from the samples, if one
  exists, otherwise `nil`. By default `sample-tester` presents the samples to
  the user and asks them to indicate a false-positive."
  ([n corpus] (sample-counter n corpus present-samples))

  ([n corpus sample-tester]
   (fn [g]
     (let [il? (in-lang g)]
       (if-let [false-neg (->> corpus
                               (filter (complement il?))
                               first)]
         false-neg
         (sample-tester
          (scfg-sample g n)))))))

(defn interactive-member
  "A form of the `member*` predicate used by the k-bounded learning algorithm
  that poses the question to the user."
  [nt yield]
  (print (str nt " =>* " (join \space yield) "? Y/N: "))
  (flush)
  (#{\y \Y} (first (read-line))))

(def interactive-learn
  ^{:doc "A specialisation of the learning algorithm that treats the user as
         the oracle"}
  (partial learn
           interactive-member
           interactive-counter))

(defn sample-learn
  "A variant of `interactive-learn` in which the user is presented with
  samples, rather than the grammar, when asked to produce counter-examples.
  Additionally, false-negatives are removed using a corpus of positive data."
  [n corpus nts]
  (learn interactive-member
         (sample-counter n corpus)
         nts))
