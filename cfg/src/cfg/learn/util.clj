(ns cfg.learn.util
  (:require [clojure.string :refer [join]]
            [bigml.sampling.stream :as stream]
            [cfg.coll-util :refer [queue]]
            [cfg.cfg  :refer [cfg add-rule]]
            [cfg.scfg :refer [cfg->scfg make-strongly-consistent sample]]
            [cfg.lang :refer [lang-seq in-lang terminal-node?]]))

(defn candidates
  "Candidate rules for given non-terminals `nts`, and terminals `ts`."
  [nts ts]
  (let [children (concat nts ts)]
    (concat
     (for [a nts, t ts] [a t])
     (for [a nts, b children, c children]
       [a b c]))))

(defn init-grammar
  "Given a sequence of non-terminals `nts`, create the initial CNF grammar for
  the learning algorithm."
  [nts ts]
  (reduce add-rule (cfg)
          (candidates nts ts)))

(defn stream-sample
  "Return a vector of `n` strings generated by the grammar `g`, randomly
  sampled from a stream of strings generated by the grammar, in length order."
  [g n]
  (-> (lang-seq g)
      (stream/sample 1 n :rate true)
      (->> (take n) vec)))

(defn scfg-sample
  "Return a vector of `n` strings generated by assignig probabilities to the
  rules in grammar `g`. This sampling system does not provide samples in
  length order, and could contain repeats."
  [g n]
  (let [sg (-> g cfg->scfg make-strongly-consistent)]
    (vec (repeatedly n #(sample sg)))))

(defn diagnose
  "Given a non-terminal membership predicate `member*`, and a parse-tree `t`,
  return a bad production used in the parse-tree."
  [member* t]
  (letfn [(consume-child [state [rule & children]]
            (if-let [bad-child (some (fn [{cnt :nt cy :yield :as child}]
                                       (when-not (member* cnt cy) child))
                                     (remove terminal-node? children))]
              (update-in state [0] conj  bad-child)
              (update-in state [1] conj! rule)))]
    (loop [q         (queue t)
           bad-rules (transient #{})]
      (if (seq q)
        (let [{:keys [children]} (peek q)
              [q* bad-rules*] (reduce consume-child
                                      [(pop q) bad-rules]
                                      children)]
          (recur q* bad-rules*))
        (persistent! bad-rules)))))

(defn present-samples
  "Print the given vector of `samples` and ask the user to pick one."
  [samples]
  (println "Are these samples correct?")
  (doseq [[i toks] (map vector (iterate inc 1) samples)]
    (println (format "%-2d. %s" i toks)))
  (print "Blank for yes, index of counter-example for no: ")
  (flush)
  (let [input (read-line)]
    (when (seq input)
      (get samples (dec (read-string input))))))

(defn sample-counter
  "A `counter*` predicate that ensures every word in `corpus` is recognised by
  the given grammar. If not, then the offending word is returned.

  Otherwise, generates samples from the grammar, and passes them on to the
  `sample-tester` which should return a false-positive from the samples, if one
  exists, otherwise `nil`. By default `sample-tester` presents the samples to
  the user and asks them to indicate a false-positive."
  ([n corpus] (sample-counter n corpus present-samples))

  ([n corpus sample-tester]
   (fn [g]
     (let [il? (in-lang g)]
       (if-let [false-neg (->> corpus
                               (filter (complement il?))
                               first)]
         false-neg
         (sample-tester
          (scfg-sample g n)))))))

(defn interactive-member
  "A form of the `member*` predicate used by the k-bounded learning algorithm
  that poses the question to the user."
  [nt yield]
  (print (str nt " =>* " (join \space yield) "? Y/N: "))
  (flush)
  (#{\y \Y} (first (read-line))))
